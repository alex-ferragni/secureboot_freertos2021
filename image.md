# Creating a compatible image

First off, you need a main entry point for your image, which will contain a 

Now, you need an image that can be verified and run by the bootloader. A few images are already included for inspiration. Please note that the provided images are port-specific. They can be ported to other platforms, but their makefile should be adapted first.

## Requirements

Note that the images must be defined to run from the primary slot, which means that their code must be placed in the section called `IMG` in their linker scripts. Additionally, the first words of the `IMG` region should be the interrupt vector table. If you use the template [startup.c](Bootloader/Common/src/startup_template.c) file but use your own linker script, the latter one must define that the `.isr_vector` section is placed at the beginning of the `IMG` area.

Additionally, the bootloader will look for an image-specific configuration file that dictates the logging properties. For that reason, your image should include a file named `mcuboot_config/app_config.h`. The logging in question only concern the bootloader (except for the BIOS, which will always print information when it is included) and MCUboot (including its public interface, i.e., `boot_set_pending(1)` and its flash interface). This file can be left empty (in which case the relevant logging be completely disabled). You can enable such logging by defining some variables (their presence or not is what matters, use `define` or `undef` if you want to):

- `MCUBOOT_HAVE_LOGGING`, which is required to have any logging from MCUboot. Not having it defined will disable all logging, regardless of the following variables.
- `MCUBOOT_LOG_ERR_ENABLE`, which enables the error logging.
- `MCUBOOT_LOG_WRN_ENABLE`, which enables the warning logging.
- `MCUBOOT_LOG_INF_ENABLE`, which enables the information logging.
- `MCUBOOT_LOG_INTERNAL_ENABLE`, which enables logging about MCUboot's internals.
- `MCUBOOT_LOG_DBG_ENABLE`, which enables debugging logs (warning: very verbose).

A an example configuration which is suitable for images is the following:

```
#define MCUBOOT_HAVE_LOGGING
#define MCUBOOT_LOG_ERR_ENABLE
#define MCUBOOT_LOG_WRN_ENABLE
#define MCUBOOT_LOG_INTERNAL_ENABLE
#undef MCUBOOT_LOG_DBG_ENABLE
```

Given that the only relevant logs are in MCUboot's public interface, only errors and potentially warning will be logged, so it should stay quiet in that case.

## Makefile

To compile the image, it is possible to use the [common makefile](Bootloader/Common/Makefile). It will take care of compiling from scratch and will provide targets necessary to generate signed and encrypted images, as well as targets to flash them. 

First of all, a new image-specific makefile should be created. It needs to import the project configuration by using `include $(PROJECT_CONFIG)`. This way, it will have access to shared variables defined in it. Then, it can include the common makefile by using `include [path_to_git_folder]/Bootloader/Common/Makefile`. To use the common makefile, some variables should be defined in the image makefile:

- `BUILD_DIR`, which contains the path of the output build folder _which should be empty since it will be erased_.
- `SRC_FILES`, which contains the list of source files that need to be compiled.
- `INCLUDE_PATHS`, which contains the list of include paths, on the form `INCLUDE_PATHS = -I[folder1] -I[folder2] [...]`
- `TARGET`, which contains the target name (name of the output image file).
- `LDSCRIPT`, which contains the path to the linker script which contains the sections definition. This can for example be set to `[path_to_git_folder]/Bootloader/Common/link_template.ld`, or to your custom file. 
- `PATH_MCUBOOT`, which contains the path to the MCUboot folder (which is already defined in `project_config.mk`)
- `PATH_PORT`, which contains the path to the chosen port folder (which is already defined in `project_config.mk`)
- `KEY_SIGN`, which contains the path to the private signature key. In a `keys` folder generated by the bootloader's key creation tool, this correspond to `keys/imgtool_keys/key_sign_priv.pem`.
- `KEY_ENC`, which contains the path to the public encryption key. In a `keys` folder generated by the bootloader's key creation tool, this correspond to `keys/imgtool_keys/key_enc_pub.pem`.
- `SECTIONS_CONFIG_DIR`, which contains the complete path to the folder that contains a `sections_config.ld` linker script (which is already defined in `project_config.mk`).

After that, the image can be compiled via the common makefile. 

Alternatively, the makefile can be written from scratch, or by using your own (if your image already has one). However, some criteria must be filled to make your image compatible with the bootloader:

* `PROJECT_CONFIG` must be included, as in contains variables that must be shared with the bootloader
* The linker script should include `memory-sections.ld`. You may need to tell the makefile where to find this file, along with `port.ld` (in the port folder) and `sections_config.ld`, which are both included by `memory-sections.ld`. This can be done by adding `-L$(PATH_TO_A_GIVEN_LINKER_FILE)`, for all three of them, to the compilation flags.
* The image should be defined to run from the primary slot, meaning its code should be contained in the `IMG` area (symbol defined in `memory-sections.ld`)
* More specifically, the interrupt vector table should be placed in the very beggining of the `IMG` area.
* The image reset handler (i.e., second entry of the vector table) will be executed by the bootloader and should thus be your main entry point.

## Using common drivers

The image can implement its own drivers, but it can also include the common drivers that the bootloader already uses. Since some common drivers might be incompatible with your image, it is possible to individually include or exclude drivers. Let us see now how to include drivers.

Firstly, the desired driver source files should be added in the `SRC_FILES` makefile variable. Those are the source files of your port, as the common part of the drivers have no source files.

Then, the makefile should indicate which drivers should be included. There exist a variable for each driver that tells the common files whether this specific driver file should be empty or should contain definitions. By default, all drivers will be empty; including their source files is not sufficient to use them. 

To tell the common files that a driver `xxx` should be filled, a variable `HAL_INCLUDE_XXX` should be defined. For example, to use the Flash driver (`hal_flash`), the variable `HAL_INCLUDE_FLASH` should be set. For the RCC driver, `HAL_INCLUDE_RCC` should be set. Etc. They can be set using `ADDITIONAL_CFLAGS = -DHAL_INCLUDE_XXX -DHAL_INCLUDE_YYY`. This is useful because drivers may be inter-dependent, so including a driver X might automatically include driver Y, which might not be desirable. For example on the FreeRTOS image on STM32H753, the `security` drivers need to be enabled in order to use the BIOS, but this requires UART drivers, which is a problem since FreeRTOS comes with its own UART drivers.

Consequently, incompatiblities might appear when not using some drivers that are necessary (e.g., not including the UART driver but enabling MCUboot's logging). The missing definitions should then be defined by your image itself (this will effectively make the link the bootloader and your drivers). For this reason, if any driver is not included, it is necessary to add a `hal/hal_app.h` header file to your image. This file is included by the common files and can then include your own definitions of missing functions or variables, which will be usable by the rest of the poject. For example, it is possible to exclude the Flash drivers, in which case `hal/hal_app.h` will include its own implementation of the same Flash interface, or include another file that does exactly that. You can have a look at the [FreeRTOS example](FreeRTOS-Image/App/include/hal/hal_app.h) of `hal/hal_app.h` for a concrete example which makes the link with its own Flash and UART drivers. 

Additionally, there exists a special variable `HAL_INCLUDE_ALL` which will define the `HAL_INCLUDE_X` variable of every single driver. This ise useful if your image has no drivers on its own (like the `hello_world` image, or the bootloader itself).

## Update capability

Finally, any image should be capable of downloading an update. This is because the bootloader should not download an image itself and this responsability is left to the image.

More precisely, any deployment image should ___always___ include a way to download in a production build, no matter which way, an update and store it in the secondary slot of the Flash memory.

To obtain the boundaries of the secondary slot (or any slot, for that matter), one should include a variable that is defined in the common linker scripts, for example via `extern uint32_t [symbol_name];`. It is then possible to use its value with `(uint32_t)&[symbol_name]`. The beginning of the secondary slot is defined by `_stImg2Header` and it has a maximum size of `_lnImg`.

Thus, an image should always include a way to download an encrypted image (like the one freshly generated by the common makefile, i.e., `$(BUILD_DIR)/$(TARGET)_enc.bin`) and store it in the secondary slot (while checking its boundaries, if necessary).

Alternatively, this can be done by including the utility BIOS in the image, since it is fully capable of downloading an image via UART. See the [Utility BIOS](utility_bios.md) section.

Lastly, the update should be marked for an update in order to be processed by the bootloader. This must be done by the `boot_set_pending(1)` function, defined in `$(PATH_MCUBOOT)/boot/bootutil/src/bootutil.c` (which should thus be included in the makefile, along with `-I$(PATH_MCUBOOT)/boot/bootutil/include`, which should be added to `INCLUDE_PATHS`). The update will then be processed and applied after the next reset.
